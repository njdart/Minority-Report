import cv2
import numpy as np
import math

class GraphExtractor:
    """Get postits from a board image"""
    def __init__(self, image):
        self.DEBUG_PLOT = False
        self.rawImage = image
        self.image = image
        self.postitPos = []
        self.postitImage = []
        self.postitColour = []
        self.lineEnds = []

        self.ColourThresholds = {
            "ORANGE": {
                "min_rg": 0,
                "max_rg": 70,
                "min_rb": 60,
                "max_rb": 150,
                "min_gb": 25,
                "max_gb": 100
            },
            "YELLOW": {
                "min_rg": -30,
                "max_rg": 15,
                "min_rb": 35,
                "max_rb": 120,
                "min_gb": 40,
                "max_gb": 125
            },
            "BLUE": {
                "min_rg": -80,
                "max_rg": -20,
                "min_rb": -120,
                "max_rb": -40,
                "min_gb": -45,
                "max_gb":   0
            },
            "MAGENTA": {
                "min_rg": 40,
                "max_rg": 135,
                "min_rb": 25,
                "max_rb": 90,
                "min_gb": -55,
                "max_gb": -10
            },
        }

    def extractGraph(self, showDebug=False, sigma=0.8, minPostitArea = 3000, maxPostitArea = 20000, lenTolerence = 0.15, minColourThresh = 64, maxColourThresh = 200):
        postits = self.extractPostits(showDebug, sigma, minPostitArea, maxPostitArea, lenTolerence, minColourThresh, maxColourThresh)
        lines =  self.extractLines(postits, showDebug, sigma)
        graph = {
                "postits": postits,
                "lines": lines
            }
        return graph

    def extractPostits(self, showDebug=False, sigma=0.8, minPostitArea = 3000, maxPostitArea = 20000, lenTolerence = 0.15, minColourThresh = 64, maxColourThresh = 200):

        foundPostits = []
        img = self.image

        edged = cv2.Canny(img, 0, 90)
        cv2.imwrite("image.jpg",edged)

        v = np.median(img)
        lower = int(max(0, (1.0 - sigma) * v))
        upper = int(min(255, (1.0 + sigma) * v))
        edged = cv2.Canny(img, 0, 90)


        (_,cnts, _) = cv2.findContours(edged.copy(), cv2.RETR_TREE, cv2.CHAIN_APPROX_TC89_KCOS)
        for c in cnts:
            box = cv2.boxPoints(cv2.minAreaRect(c))
            box = np.int0(box)
            if ((cv2.contourArea(box) > minPostitArea) and (cv2.contourArea(box) < maxPostitArea)):
                length = math.hypot(box[0,0]-box[1,0], box[0,1]-box[1,1])
                height = math.hypot(box[2,0]-box[1,0], box[2,1]-box[1,1])
                if (length*(2-lenTolerence) < length+height < length*(2+lenTolerence)):
                    Rectangle = cv2.boundingRect(c)
                    if showDebug:
                        print(cv2.contourArea(box))
                        cv2.drawContours(img, [box], 0, (0, 255, 0), 3)
                    self.postitPos.append(Rectangle)
                    self.postitImage.append(img[Rectangle[1]:(Rectangle[1]+Rectangle[3]), Rectangle[0]:(Rectangle[0]+Rectangle[2])])
        if showDebug:

            #cv2.imshow("Canny edge detection", edged)
            #cv2.imshow("Canvas Extracted", img)
            cv2.imwrite("image.jpg",edged)
            #cv2.imwrite("image.jpg",img)
            cv2.waitKey(0)

        for idx, postit in enumerate(self.postitImage):

            gray = cv2.cvtColor(postit, cv2.COLOR_BGR2GRAY)
            rTotal = gTotal = bTotal = 0
            count = 0
            #print(postit.shape)
            (width, height, depth) = postit.shape
            for y in range(height):
                for x in range(width):
                    if minColourThresh < gray[x,y] < maxColourThresh:
                        b, g, r = postit[x,y]
                        rTotal += r
                        gTotal += g
                        bTotal += b

            count = width * height

            rAvg = rTotal / count
            gAvg = gTotal / count
            bAvg = bTotal / count

            guessedColour = self.guess_colour(rAvg, gAvg, bAvg)
            self.postitColour.append(guessedColour)

            foundPostit = {
                "image": postit,
                "colour": guessedColour,
                "position": self.postitPos[idx]

            }

            foundPostits.append(foundPostit)

        return foundPostits

    def guess_colour(self, r, g, b):
        r = int(r)
        g = int(g)
        b = int(b)
        rg = r - g
        rb = r - b
        gb = g - b
        for colour in self.ColourThresholds:
            if ((rg >= self.ColourThresholds[colour]["min_rg"]) and
                    (rg <= self.ColourThresholds[colour]["max_rg"]) and
                    (rb >= self.ColourThresholds[colour]["min_rb"]) and
                    (rb <= self.ColourThresholds[colour]["max_rb"]) and
                    (gb >= self.ColourThresholds[colour]["min_gb"]) and
                    (gb <= self.ColourThresholds[colour]["max_gb"])):
                return colour

        return None

    def getFeatures(self):
        pass

    def extractLines(self, postits, showDebug=False, sigma=0.8):
        foundLines = []
        img = self.image

        gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)
        v = np.median(img)
        lower = int(max(0, (1.0 - sigma) * v))
        upper = int(min(255, (1.0 + sigma) * v))
        edged = cv2.Canny(img, lower, upper)

        (_,cnts, _) = cv2.findContours(edged.copy(), cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)


        for c in cnts:
            postitIdx = [-1,-1]

            startPoint, endPoint = self.findFurthestPair(c)

            for idxstart, postit in enumerate(postits):
                if postit["position"][0] < startPoint[0] < postit["position"][0]+postit["position"][2] and postit["position"][1] < startPoint[1] < postit["position"][1]+postit["position"][3]:
                    postitIdx[0] = idxstart

            for idxend, postit in enumerate(postits):
                if postit["position"][0] < endPoint[0] < postit["position"][0]+postit["position"][2] and postit["position"][1] < endPoint[1] < postit["position"][1]+postit["position"][3]:
                    postitIdx[1] = idxend

            if postitIdx[0] > -1 and postitIdx[1] > -1:
                foundLines.append(postitIdx)


            if showDebug:
                cImg = img.copy()
                cv2.line(cImg,startPoint,endPoint,(255,0,0),5)
                cv2.imshow("Contours", cImg)
                cv2.waitKey(0)


        if showDebug:
            cv2.imshow("Lines Extracted", img)
            cv2.waitKey(0)


        return foundLines

    def findFurthestPair(self, contour):
        distList =  np.zeros((4,4))

        leftmost = tuple(contour[contour[:,:,0].argmin()][0])
        rightmost = tuple(contour[contour[:,:,0].argmax()][0])
        topmost = tuple(contour[contour[:,:,1].argmin()][0])
        bottommost = tuple(contour[contour[:,:,1].argmax()][0])
        points = [leftmost, rightmost, topmost, bottommost]

        for idxa, pointa in enumerate(points):
            for idxb, pointb in enumerate(points):
                distList[idxa, idxb,] = math.hypot(pointa[0]-pointb[0],pointa[1]-pointb[1])
        maxDistIdx = np.argmax(distList, axis=None)
        maxDistIdx = np.unravel_index(maxDistIdx, distList.shape)
        start = points[maxDistIdx[0]]
        end = points[maxDistIdx[1]]
        return(start, end)




def findCanvas(image, showDebug=False):

    (__, board) = cv2.threshold(image,100,255,cv2.THRESH_TOZERO)
    grayBoard = cv2.cvtColor(board, cv2.COLOR_RGB2GRAY)



    (__, boardContours, __) = cv2.findContours(grayBoard, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    areas = [cv2.contourArea(c) for c in boardContours]

    max_index = np.argmax(areas)
    canvasContour = boardContours[max_index]
    canvasBounds = cv2.boundingRect(canvasContour)

    if showDebug:
        for c in boardContours:
            rect = cv2.minAreaRect(c)
            box = cv2.boxPoints(rect)
            box = np.int0(box)
            cv2.drawContours(image,[box],0,(0,0,255),2)

        cv2.waitKey(0)

    return canvasBounds


if __name__ == "__main__":
    canvImg = cv2.imread("IMG_20160304_154758.jpg")
    canvArea = findCanvas(canvImg)
    image = cv2.imread("IMG_20160304_154813.jpg")
    image = image[canvArea[1]:(canvArea[1]+canvArea[3]), canvArea[0]:(canvArea[0]+canvArea[2])]

    extractor = GraphExtractor(image)
    graph = extractor.extractGraph(minPostitArea = 3000, maxPostitArea = 2000000, lenTolerence = 0.4, sigma=0.99)
    num = 0

    for postit in graph["postits"]:
        cv2.imshow("Postit %d" %(num),postit["image"])
        print(postit["colour"])
        print(postit["position"])
        num += 1
    cv2.waitKey(0)
#http://opencv-python-tutroals.readthedocs.org/en/latest/py_tutorials/py_feature2d/py_feature_homography/py_feature_homography.html


